{"instruction": "Explica qué es una tupla en TypeScript", "response": "Una tupla en TypeScript es un arreglo de longitud fija donde cada elemento tiene un tipo específico. Por ejemplo: `let punto: [number, number] = [10, 20];`"}
{"instruction": "¿Cuál es la diferencia entre 'any' y 'unknown'?", "response": "'any' desactiva la verificación de tipos, mientras que 'unknown' es un tipo seguro que requiere verificación antes de su uso. Con 'unknown' debes hacer type narrowing."}
{"instruction": "Corrige este error: 'let x: string = 5;'", "response": "El error es asignar un número a una variable string. Corrección: `let x: number = 5;` o `let x: string = '5';`"}
{"instruction": "¿Para qué sirve 'readonly' en TypeScript?", "response": "'readonly' hace que una propiedad sea de solo lectura, impidiendo su modificación después de la inicialización. Se usa en interfaces y clases."}
{"instruction": "Explica la utilidad de los tipos genéricos", "response": "Los genéricos permiten crear componentes reutilizables que funcionan con múltiples tipos manteniendo la seguridad de tipos. Ejemplo: `function identity<T>(arg: T): T { return arg; }`"}
{"instruction": "Muestra cómo usar 'enums' numéricos", "response": "Los enums numéricos asignan valores automáticamente desde 0: `enum Direccion { Norte, Sur, Este, Oeste }` o manualmente: `enum Codigo { Exito = 200, Error = 500 }`"}
{"instruction": "¿Cómo tipar un objeto con propiedades opcionales?", "response": "Usa el operador '?': `interface Usuario { nombre: string; edad?: number; }`. Así 'edad' es opcional."}
{"instruction": "Corrige: 'function suma(a: number, b: number): string { return a + b; }'", "response": "El tipo de retorno debe ser 'number': `function suma(a: number, b: number): number { return a + b; }`"}
{"instruction": "Explica 'type narrowing' con ejemplo", "response": "Es reducir el tipo de una variable dentro de un bloque. Ejemplo con 'typeof': `if (typeof valor === 'string') { console.log(valor.toUpperCase()); }`"}
{"instruction": "Muestra la sintaxis de 'type assertions'", "response": "Hay dos formas: con '<>' o 'as': `let longitud: number = (<string>valor).length;` o `let longitud: number = (valor as string).length;`"}
{"instruction": "¿Cómo importar tipos en módulos?", "response": "Usa 'import type': `import type { Usuario } from './types';` o `import { type Usuario } from './types';` en versiones recientes."}
{"instruction": "Explica 'keyof' con ejemplo práctico", "response": "'keyof' obtiene las claves de un tipo: `interface Persona { nombre: string; edad: number; } type Claves = keyof Persona; // 'nombre' | 'edad'`"}
{"instruction": "Corrige: 'const lista: Array<number> = [1, '2', 3];'", "response": "El array solo debe contener números: `const lista: Array<number> = [1, 2, 3];` o cambiar el tipo a `Array<string | number>`."}
{"instruction": "Muestra un ejemplo de 'intersection types'", "response": "Combina múltiples tipos: `interface Nombre { nombre: string; } interface Edad { edad: number; } type Persona = Nombre & Edad;`"}
{"instruction": "¿Qué son 'utility types'? Da 3 ejemplos", "response": "Tipos predefinidos para transformaciones. Ejemplos: `Partial<T>` hace todas las propiedades opcionales, `Pick<T, K>` selecciona propiedades, `Omit<T, K>` las excluye."}
{"instruction": "Corrige: 'interface A { x: number; }; interface A { y: string; }'", "response": "Las interfaces se fusionan automáticamente, no es un error. Pero si no quieres fusión, usa 'type': `type A = { x: number; y: string; };`"}
{"instruction": "Explica 'typeof' en contexto de tipos", "response": "Obtiene el tipo de una variable: `let x = 5; type TipoX = typeof x; // number`. Útil para derivar tipos de constantes."}
{"instruction": "Muestra cómo usar 'satisfies' operator", "response": "Verifica que un valor cumple un tipo sin cambiar su inferencia: `const colores = { rojo: '#FF0000' } satisfies Record<string, string>;`"}
{"instruction": "¿Cómo tipar funciones asíncronas?", "response": "Usa `Promise<T>`: `async function getData(): Promise<string> { return 'datos'; }`"}
{"instruction": "Corrige: 'type X = string | number; let y: X = true;'", "response": "'boolean' no está en el tipo X. Corrección: `let y: X = 10;` o añadir 'boolean' al tipo: `type X = string | number | boolean;`"}
{"instruction": "Explica 'mapped types' con ejemplo", "response": "Transforma propiedades existentes: `type SoloLectura<T> = { readonly [K in keyof T]: T[K]; };`. Crea un nuevo tipo con todas las propiedades de solo lectura."}
{"instruction": "Muestra la sintaxis de 'function overloads'", "response": "Se definen varias firmas antes de la implementación: `function procesar(x: string): string; function procesar(x: number): number; function procesar(x: any): any { return x; }`"}
{"instruction": "¿Cómo usar 'this' en tipos de funciones?", "response": "Especifica el tipo de 'this' en el primer parámetro: `function imprimir(this: HTMLElement) { console.log(this.tagName); }`"}
{"instruction": "Corrige: 'const arr: readonly number[] = [1,2,3]; arr.push(4);'", "response": "No se puede modificar un array readonly. Elimina 'push' o quita 'readonly': `const arr: number[] = [1,2,3]; arr.push(4);`"}
{"instruction": "Explica 'conditional types' básicos", "response": "Tipos que dependen de una condición: `type EsString<T> = T extends string ? 'Sí' : 'No'; type Resultado = EsString<number>; // 'No'`"}
{"instruction": "Muestra un tipo para eventos de click", "response": "`type ClickHandler = (event: MouseEvent) => void;` o más específico: `(event: React.MouseEvent<HTMLButtonElement>) => void` para React."}
{"instruction": "¿Cómo restringir genéricos con 'extends'?", "response": "Especifica una restricción: `function longitud<T extends { length: number }>(obj: T): number { return obj.length; }`"}
{"instruction": "Corrige: 'let x: number | string = 5; x.toUpperCase();'", "response": "Debes verificar el tipo primero: `if (typeof x === 'string') x.toUpperCase();` o usar 'as string' solo si estás seguro."}
{"instruction": "Explica 'infer' en conditional types", "response": "Extrae un tipo dentro de otro: `type Elemento<T> = T extends Array<infer U> ? U : never; type Numero = Elemento<number[]>; // number`"}
{"instruction": "Muestra cómo tipar 'fetch' con async/await", "response": "`async function fetchData(url: string): Promise<{data: any}> { const response = await fetch(url); return response.json(); }`"}
{"instruction": "¿Qué es 'never' y cuándo usarlo?", "response": "'never' representa valores que nunca ocurren. Se usa en funciones que siempre lanzan errores o en type narrowing exhaustivo."}
{"instruction": "Corrige: 'type Props = { children: string }; function Component(props: Props) { return <div>{props.children}</div> }'", "response": "Para React, 'children' puede ser también ReactNode: `type Props = { children: React.ReactNode };`"}
{"instruction": "Explica 'template literal types'", "response": "Generan tipos a partir de strings: `type Evento = 'click' | 'hover'; type Handler = `on${Evento}`; // 'onclick' | 'onhover'`"}
{"instruction": "Muestra cómo declarar módulos globales", "response": "En un archivo .d.ts: `declare module '*.svg' { const content: string; export default content; }`"}
{"instruction": "¿Cómo tipar un reducer en Redux?", "response": "`type Action = { type: 'INCREMENT'; payload: number } | { type: 'DECREMENT' }; function reducer(state: number, action: Action): number { ... }`"}
{"instruction": "Corrige: 'function f(x?: number) { return x + 1; }'", "response": "'x' podría ser undefined. Usa un valor por defecto: `function f(x?: number) { return (x ?? 0) + 1; }`"}
{"instruction": "Explica 'branded types' para nominal typing", "response": "Simula tipado nominal con marcas: `type UserId = string & { readonly brand: unique symbol }; function createUserId(id: string): UserId { return id as UserId; }`"}
{"instruction": "Muestra cómo usar 'Awaited<T>' utility", "response": "Extrae el tipo resuelto de una Promise: `type Respuesta = Awaited<Promise<string>>; // string`. Útil para funciones async."}
{"instruction": "¿Cómo tipar objetos dinámicos con 'Record'?", "response": "`Record<K, T>` crea un objeto con claves K y valores T: `const usuarios: Record<string, {edad: number}> = { 'Juan': {edad: 30} };`"}
{"instruction": "Corrige: 'class A { private x = 1; } new A().x;'", "response": "'x' es privado y no accesible fuera. Cambia a 'public' o usa un getter: `class A { public x = 1; }` o `class A { private x = 1; getX() { return this.x; } }`"}
{"instruction": "Explica 'const assertions'", "response": "`as const` hace que un valor sea de tipo literal inmutable: `const colores = ['rojo', 'verde'] as const; // tipo readonly ['rojo', 'verde']`"}
{"instruction": "Muestra un tipo para formularios con validación", "response": "`type FormState = { valores: Record<string, string>; errores: Record<string, string>; isValid: boolean; }`"}
{"instruction": "¿Cómo usar 'Exclude' y 'Extract'?", "response": "'Exclude<T, U>' excluye tipos de T asignables a U. 'Extract<T, U>' extrae los que sí son asignables. Ejemplo: `type T = Exclude<'a'|'b'|'c', 'a'>; // 'b'|'c'`"}
{"instruction": "Corrige: 'interface Figura { area(): number; } class Circulo implements Figura { radio = 5; }'", "response": "Falta implementar 'area': `class Circulo implements Figura { radio = 5; area() { return Math.PI * this.radio ** 2; } }`"}
{"instruction": "Explica 'index signatures' para objetos genéricos", "response": "Permiten propiedades dinámicas: `interface Diccionario { [key: string]: number; }`. Todas las claves string deben tener valores number."}
{"instruction": "Muestra cómo tipar 'useState' en React", "response": "`const [count, setCount] = useState<number>(0);` o con tipo inferido: `const [count, setCount] = useState(0);`"}
{"instruction": "¿Qué es 'declaration merging'?", "response": "Cuando TypeScript fusiona múltiples declaraciones del mismo nombre. Común en interfaces: `interface A { x: number; } interface A { y: string; } // se fusionan`"}
{"instruction": "Corrige: 'type T = { a: number }; type T = { b: string };'", "response": "Los tipos no se fusionan como las interfaces. Usa intersección: `type T = { a: number } & { b: string };` o define todo en un solo tipo."}
{"instruction": "Explica 'in operator' type narrowing", "response": "Verifica si una propiedad existe: `if ('x' in obj) { console.log(obj.x); }`. TypeScript sabe que 'obj' tiene 'x' dentro del bloque."}
{"instruction": "Muestra un tipo para funciones constructoras", "response": "`interface Constructor { new (x: number): MiClase; }` o `type Constructor = new (...args: any[]) => any;`"}
{"instruction": "¿Cómo tipar props de componentes React?", "response": "`type Props = { titulo: string; activo?: boolean; hijos?: React.ReactNode; onClick: () => void; };`"}
{"instruction": "Corrige: 'function f(x: number): number; function f(x: string): string; function f(x: any) { return x; }'", "response": "Las sobrecargas están bien, pero para mayor seguridad usa uniones: `function f(x: number | string): number | string { return x; }` aunque pierdes relación entre entrada/salida."}
{"instruction": "Explica 'type predicates' personalizados", "response": "Funciones que devuelven un predicado: `function esString(valor: any): valor is string { return typeof valor === 'string'; }`. Luego TypeScript narrows el tipo."}
{"instruction": "Muestra cómo usar 'Parameters' y 'ReturnType'", "response": "Obtienen parámetros y tipo de retorno de una función: `type Params = Parameters<(x: number, y: string) => void>; // [number, string]` `type Ret = ReturnType<typeof Math.max>; // number`"}
{"instruction": "¿Cómo tipar eventos de cambio en inputs?", "response": "`const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => { console.log(e.target.value); };` o para nativos: `(e: Event) =>` con type assertion."}
{"instruction": "Corrige: 'const [state, setState] = useState()'", "response": "Falta el tipo genérico o valor inicial. Corrección: `const [state, setState] = useState<number>(0);` o `useState(null as string | null);`"}
{"instruction": "¿Qué es un tipo de unión (union type) en TypeScript?", "response": "Un tipo de unión permite que una variable tenga más de un tipo. Se define usando el operador '|'. Por ejemplo: `let id: number | string;` significa que 'id' puede ser un número o una cadena."}
{"instruction": "Corrige este código: 'let user = { name: \"John\", age: 30 }; user.location;'", "response": "La propiedad 'location' no existe en el objeto 'user'. Si quieres acceder a una propiedad que no está definida, TypeScript dará un error. Debes definirla primero: `let user = { name: \"John\", age: 30, location: \"NYC\" };` o usar un tipo que la incluya."}
{"instruction": "Explica cómo usar 'interface' para definir un contrato de objetos.", "response": "Una interfaz define la forma de un objeto. Por ejemplo: `interface Person { name: string; age: number; }` Luego puedes usarla para tipar un objeto: `let john: Person = { name: \"John\", age: 30 };`"}
{"instruction": "¿Cómo se define un tipo para un array de números en TypeScript?", "response": "Hay dos formas comunes: `let numbers: number[] = [1, 2, 3];` o `let numbers: Array<number> = [1, 2, 3];`. Ambas son equivalentes."}
{"instruction": "Muestra cómo usar la palabra clave 'implements' en una clase.", "response": "Usas 'implements' para que una clase cumpla con una interfaz. Ejemplo: `interface Animal { sound(): void; } class Dog implements Animal { sound() { console.log(\"Woof\"); } }`"}
{"instruction": "Corrige: 'function greet(name: string): void { return `Hello, ${name}`; }'", "response": "La función declara que retorna 'void', pero retorna una cadena. Debes cambiar el tipo de retorno: `function greet(name: string): string { return `Hello, ${name}`; }`"}
{"instruction": "Explica el uso de 'namespace' en TypeScript y si todavía se recomienda.", "response": "Los namespaces se usaban para organizar código en versiones antiguas. Hoy se recomienda usar módulos ES6 (import/export) en su lugar. Sin embargo, aún se usan en algunos contextos, como definiciones de tipos para librerías."}
{"instruction": "¿Qué es y cómo se usa 'type alias'?", "response": "Un type alias crea un nuevo nombre para un tipo. Por ejemplo: `type StringOrNumber = string | number; let value: StringOrNumber;`. Puede representar cualquier tipo, incluyendo primitivos, uniones, intersecciones, etc."}
{"instruction": "Corrige: 'let x: number = 10; x = \"20\";'", "response": "No puedes asignar una cadena a una variable de tipo número. Corrección: `let x: number = 10; x = 20;` o cambia el tipo: `let x: string | number = 10; x = \"20\";`"}
{"instruction": "Explica cómo funciona la inferencia de tipos en TypeScript.", "response": "TypeScript infiere el tipo de una variable cuando no se lo das explícitamente, basándose en el valor inicial. Por ejemplo: `let x = 10;` infiere que x es de tipo 'number'. También infiere en el retorno de funciones, etc."}
{"instruction": "Muestra un ejemplo de cómo usar 'readonly array'.", "response": "Un array readonly no puede ser modificado después de su creación. Se define así: `let numbers: readonly number[] = [1, 2, 3];` o `let numbers: ReadonlyArray<number> = [1, 2, 3];`. No se puede usar push, pop, etc."}
{"instruction": "¿Cómo se tipa un objeto con propiedades dinámicas usando un índice?", "response": "Puedes usar una firma de índice. Por ejemplo: `interface Dictionary { [key: string]: number; }` permite que el objeto tenga cualquier clave string con valor number."}
{"instruction": "Corrige: 'let x: any = 10; let y: number = x;'", "response": "No hay error en el código, pero usar 'any' pierde la seguridad de tipos. Si sabes que x es un número, es mejor no usar 'any' o hacer una verificación. Por ejemplo: `let x: unknown = 10; let y: number = x as number;`"}
{"instruction": "Explica la diferencia entre 'interface' y 'type'.", "response": "Ambos pueden usarse para definir formas de objetos, pero 'type' puede representar más tipos (uniones, intersecciones, primitivos, etc.). Las interfaces son más extensibles (pueden fusionarse) y se usan más para objetos y clases."}
{"instruction": "Muestra cómo usar 'Omit' utility type.", "response": "`Omit<T, K>` crea un tipo excluyendo las propiedades K de T. Ejemplo: `interface Person { name: string; age: number; location: string; } type PersonWithoutLocation = Omit<Person, 'location'>;`"}
{"instruction": "¿Cómo tipar una función que recibe un callback?", "response": "Puedes tipar el callback como una función. Ejemplo: `function procesar(callback: (resultado: string) => void) { callback(\"hecho\"); }`"}
{"instruction": "Corrige: 'function printId(id: number | string) { console.log(id.toUpperCase()); }'", "response": "El método 'toUpperCase' no existe en 'number'. Debes hacer una verificación: `function printId(id: number | string) { if (typeof id === \"string\") { console.log(id.toUpperCase()); } else { console.log(id); } }`"}
{"instruction": "Explica cómo usar 'as const' para hacer un objeto inmutable a nivel de tipos.", "response": "`as const` hace que TypeScript trate el objeto como literal y de solo lectura. Ejemplo: `let colors = { red: \"#FF0000\", green: \"#00FF00\" } as const;` Ahora los valores son literales y las propiedades readonly."}
{"instruction": "Muestra cómo definir un tipo para un componente de React con props.", "response": "Puedes usar `type` o `interface`. Ejemplo: `type ButtonProps = { text: string; onClick: () => void; disabled?: boolean; }; const Button: React.FC<ButtonProps> = ({ text, onClick, disabled }) => { ... }`"}
{"instruction": "¿Qué es un 'non-null assertion operator' y cómo se usa?", "response": "Es el operador '!' y le dice a TypeScript que una variable no es null o undefined. Ejemplo: `let x: string | null = getString(); let y: string = x!;`. Úsalo solo cuando estés seguro."}
{"instruction": "Corrige: 'class Animal { constructor(public name: string) {} } class Dog extends Animal { bark() { console.log(\"Woof\"); } } let dog = new Dog(); dog.bark();'", "response": "Al crear una instancia de Dog, debes pasar el parámetro 'name' al constructor. Corrección: `let dog = new Dog(\"Rex\"); dog.bark();`"}
{"instruction": "Explica cómo usar 'Pick' utility type.", "response": "`Pick<T, K>` crea un tipo seleccionando un conjunto de propiedades K de T. Ejemplo: `interface Person { name: string; age: number; location: string; } type PersonName = Pick<Person, 'name'>;`"}
{"instruction": "Muestra cómo tipar un evento de formulario en React.", "response": "Para un evento de cambio en un input: `const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => { console.log(e.target.value); };`"}
{"instruction": "¿Cómo se define un tipo para una función que puede recibir múltiples argumentos de diferentes tipos?", "response": "Puedes usar uniones en los parámetros, pero si la relación entre entrada y salida es compleja, considera sobrecargas. Ejemplo simple: `function procesar(input: string | number): string | number { ... }`"}
{"instruction": "Corrige: 'let x: unknown = \"hello\"; let y: string = x;'", "response": "No puedes asignar un 'unknown' directamente a un 'string' sin asegurar el tipo. Usa una verificación o una aserción: `if (typeof x === \"string\") { let y: string = x; }` o `let y: string = x as string;`"}
{"instruction": "Explica cómo usar 'Partial' utility type.", "response": "`Partial<T>` hace que todas las propiedades de T sean opcionales. Útil para actualizaciones. Ejemplo: `interface Person { name: string; age: number; } function updatePerson(person: Person, fields: Partial<Person>) { return { ...person, ...fields }; }`"}
{"instruction": "Muestra un ejemplo de 'type guard' con 'instanceof'.", "response": "`instanceof` verifica si un objeto es instancia de una clase. Ejemplo: `class Dog { bark() {} } class Cat { meow() {} } function hacerSonido(animal: Dog | Cat) { if (animal instanceof Dog) { animal.bark(); } else { animal.meow(); } }`"}
{"instruction": "¿Cómo se tipa un hook personalizado en React que retorna un valor y un setter?", "response": "Puedes retornar una tupla. Ejemplo: `function useCustomHook(initialValue: string): [string, (value: string) => void] { const [value, setValue] = useState(initialValue); return [value, setValue]; }`"}
{"instruction": "Corrige: 'interface Box<T> { value: T; } let box: Box = { value: 10 };'", "response": "Al usar un tipo genérico, debes especificar el tipo. Corrección: `let box: Box<number> = { value: 10 };`"}
{"instruction": "Explica cómo usar 'Record' utility type para un mapa de strings a números.", "response": "`Record<string, number>` crea un tipo con claves string y valores number. Ejemplo: `let scores: Record<string, number> = { \"Alice\": 100, \"Bob\": 90 };`"}
{"instruction": "Muestra cómo definir un tipo para un componente que acepta 'children'.", "response": "Puedes usar `React.ReactNode` para children. Ejemplo: `type Props = { children: React.ReactNode; }; const Container: React.FC<Props> = ({ children }) => <div>{children}</div>;`"}
{"instruction": "¿Qué es 'declaration merging' y cómo funciona con interfaces?", "response": "Declaration merging es cuando TypeScript combina múltiples declaraciones con el mismo nombre. Para interfaces, se fusionan las propiedades. Ejemplo: `interface A { x: number; } interface A { y: string; }` se convierte en `{ x: number; y: string; }`."}
{"instruction": "Corrige: 'type Status = \"pending\" | \"success\" | \"error\"; let currentStatus: Status = \"failed\";'", "response": "\"failed\" no está en el tipo Status. Debe ser uno de los valores: `let currentStatus: Status = \"pending\";` o agregar \"failed\" al tipo."}
{"instruction": "Explica cómo usar 'Extract' utility type.", "response": "`Extract<T, U>` extrae de T los tipos que son asignables a U. Ejemplo: `type T = Extract<\"a\" | \"b\" | \"c\", \"a\" | \"f\">; // \"a\"`"}
{"instruction": "Muestra cómo tipar una función que recibe un objeto de opciones con valores por defecto.", "response": "Puedes usar un tipo para las opciones y una función que las combine con valores por defecto. Ejemplo: `type Options = { color?: string; size?: number; }; function createButton(options: Options) { const settings = { color: \"blue\", size: 10, ...options }; }`"}
{"instruction": "¿Cómo se define un tipo para un array que debe tener al menos un elemento?", "response": "Puedes usar una tupla con un elemento requerido y el resto opcional: `type NonEmptyArray<T> = [T, ...T[]];` o `type NonEmptyArray<T> = [T, ...T[]];`"}
{"instruction": "Corrige: 'function getProperty(obj: any, key: string) { return obj[key]; }'", "response": "Usar 'any' no es seguro. Mejor usa genéricos: `function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] { return obj[key]; }`"}
{"instruction": "Explica cómo usar 'NonNullable' utility type.", "response": "`NonNullable<T>` excluye null y undefined de T. Ejemplo: `type T = string | null | undefined; type Clean = NonNullable<T>; // string`"}
{"instruction": "Muestra cómo tipar un ref en React para un elemento input.", "response": "Usa `useRef` con el tipo adecuado: `const inputRef = useRef<HTMLInputElement>(null);` Luego, al acceder a `inputRef.current`, TypeScript sabrá que es un HTMLInputElement o null."}
{"instruction": "¿Qué es un 'mixin' en TypeScript y cómo se implementa?", "response": "Un mixin es una función que toma una clase base y retorna una nueva clase extendida. Ejemplo: `function Timestamped<TBase extends new (...args: any[]) => any>(Base: TBase) { return class extends Base { timestamp = Date.now(); }; }`"}
{"instruction": "Corrige: 'let arr = [1, 2, 3]; arr.push(\"4\");'", "response": "El array se infiere como number[], no puedes pushear un string. Si quieres un array de números y strings, decláralo como `let arr: (number | string)[] = [1, 2, 3]; arr.push(\"4\");`"}
{"instruction": "Explica cómo usar 'ThisType' utility type.", "response": "`ThisType<T>` marca el tipo de 'this' en un objeto. Se usa en configuraciones donde el contexto de 'this' es importante. Ejemplo: `let config = { log() { this.msg; } } as { log(): void } & ThisType<{ msg: string }>;`"}
{"instruction": "Muestra cómo tipar un módulo que no tiene definiciones de tipo.", "response": "Puedes crear un archivo .d.ts con una declaración de módulo. Ejemplo: `declare module 'mi-modulo';` o `declare module 'mi-modulo' { export const func: () => void; }`"}
{"instruction": "¿Cómo se tipa un objeto que puede tener propiedades adicionales de un tipo específico?", "response": "Puedes usar una firma de índice. Ejemplo: `interface FlexibleObject { [key: string]: string | number; }` permite cualquier propiedad con valor string o number."}
{"instruction": "Corrige: 'type Props = { name: string; } & { age: number; }; let props: Props = { name: \"John\" };'", "response": "Falta la propiedad 'age'. Al usar una intersección, todas las propiedades son requeridas. Agrega 'age': `let props: Props = { name: \"John\", age: 30 };`"}
{"instruction": "Explica cómo usar 'Uppercase', 'Lowercase', 'Capitalize' y 'Uncapitalize' template string types.", "response": "Estos tipos intrínsecos transforman cadenas a nivel de tipos. Ejemplo: `type Greeting = \"hello\"; type Shout = Uppercase<Greeting>; // \"HELLO\"` Funcionan en tipos literales."}
{"instruction": "Muestra cómo definir un tipo que sea un array de funciones que retornan promises.", "response": "`type AsyncFunctions = (() => Promise<string>)[];` o `type AsyncFunctions = Array<() => Promise<string>>;`"}
{"instruction": "¿Cómo se tipa un evento de teclado en React?", "response": "Para un evento de teclado en un input: `const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => { if (e.key === 'Enter') { ... } };`"}
{"instruction": "Corrige: 'function process(value: string | number): string { return value; }'", "response": "Si value es number, no se puede retornar como string sin conversión. Debes manejar ambos: `function process(value: string | number): string { return String(value); }`"}
{"instruction": "Explica cómo usar 'Parameters' y 'ReturnType' juntos para obtener el tipo de retorno de una función con ciertos parámetros.", "response": "Puedes usarlos anidados. Ejemplo: `function foo(x: number, y: string): boolean { ... } type Params = Parameters<typeof foo>; // [number, string] type Ret = ReturnType<typeof foo>; // boolean`"}
{"instruction": "Muestra cómo tipar un componente de React que es un botón y acepta todas las props nativas de un botón.", "response": "Puedes usar `React.ComponentPropsWithoutRef<'button'>`. Ejemplo: `type ButtonProps = React.ComponentPropsWithoutRef<'button'>; const Button = (props: ButtonProps) => <button {...props} />;`"}
{"instruction": "¿Cómo se define un tipo que represente un número entre 1 y 100?", "response": "TypeScript no tiene tipos numéricos específicos, pero puedes usar una intersección con `number` y una marca. Ejemplo: `type OneToHundred = number & { readonly __brand: unique symbol };` pero necesitarías una función de validación."}
{"instruction": "Corrige: 'let x: string | null = null; console.log(x.length);'", "response": "No puedes acceder a 'length' de null. Debes verificar primero: `if (x !== null) { console.log(x.length); }` o usar el operador opcional: `console.log(x?.length);`"}
{"instruction": "Explica cómo usar 'infer' para extraer el tipo de retorno de una función dentro de un conditional type.", "response": "Puedes usar 'infer' en un conditional type para extraer un tipo. Ejemplo: `type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;` Esto extrae el tipo de retorno de una función."}
{"instruction": "Muestra cómo tipar un objeto que es tanto 'A' como 'B' (intersección).", "response": "Usa el operador '&'. Ejemplo: `interface A { x: number; } interface B { y: string; } type C = A & B; // { x: number; y: string; }`"}
{"instruction": "¿Cómo se tipa una función que puede ser llamada de dos maneras diferentes (sobrecarga)?", "response": "Declara las firmas de la función y luego la implementación. Ejemplo: `function createDate(timestamp: number): Date; function createDate(year: number, month: number, day: number): Date; function createDate(...args: any[]): Date { if (args.length === 1) { return new Date(args[0]); } else { return new Date(args[0], args[1], args[2]); } }`"}
{"instruction": "¿Cómo definir tipos para métodos de un objeto?", "response": "Puedes definir métodos en interfaces/types: `interface Calculadora { sumar(a: number, b: number): number; restar: (a: number, b: number) => number; }`"}
{"instruction": "Corrige: 'type User = { name: string; age: number } | string; const u: User = { name: 'John' };'", "response": "Falta la propiedad 'age' en el objeto. Corrección: `const u: User = { name: 'John', age: 30 };` o usar string: `const u: User = 'John';`"}
{"instruction": "Explica 'as const' vs 'readonly'", "response": "'as const' hace todo readonly e inferencia literal: `const colors = ['red', 'blue'] as const;`. 'readonly' solo marca propiedades: `interface Props { readonly items: string[]; }`"}
{"instruction": "Muestra cómo tipar eventos de formulario en React", "response": "`const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => { e.preventDefault(); const data = new FormData(e.currentTarget); };`"}
{"instruction": "¿Cómo usar 'NonNullable' utility type?", "response": "Elimina null/undefined de unión: `type T = string | null | undefined; type Clean = NonNullable<T>; // string` Útil para limpiar tipos."}
{"instruction": "Corrige: 'function procesar<T extends string>(arg: T): T { return arg.toUpperCase(); }'", "response": "toUpperCase() devuelve string, no T. Usa aserción: `function procesar<T extends string>(arg: T): T { return arg.toUpperCase() as T; }` o cambia retorno a string."}
{"instruction": "Explica 'infer' en tipos condicionales para funciones", "response": "Extrae tipos de funciones: `type Retorno<T> = T extends (...args: any[]) => infer R ? R : never; type X = Retorno<() => string>; // string`"}
{"instruction": "Muestra cómo tipar un objeto con propiedades computadas", "response": "Usa `Record` o índice: `type Config = Record<string, boolean>;` o `interface Dynamic { [key: string]: number | string; }`"}
{"instruction": "¿Cómo tipar componentes que aceptan forwardRef en React?", "response": "`const Component = forwardRef<HTMLInputElement, Props>((props, ref) => { return <input ref={ref} {...props} />; });` El primer genérico es el tipo del ref."}
{"instruction": "Corrige: 'type A = { x: number }; type B = { y: string }; type C = A | B; const c: C = { x: 1, y: 'hi' };'", "response": "C es unión, no intersección. Corrección: `type C = A & B;` o asignar solo una propiedad: `const c: C = { x: 1 };`"}
{"instruction": "Explica 'mapped types' con modificadores", "response": "Puedes añadir/remover modificadores: `type Mutable<T> = { -readonly [K in keyof T]: T[K]; };` El '-' quita readonly, '+' lo añade (por defecto)."}
{"instruction": "Muestra cómo tipar un custom hook con useReducer", "response": "`function useCounter(): [number, () => void] { const [state, dispatch] = useReducer(reducer, 0); const increment = () => dispatch({ type: 'increment' }); return [state, increment]; }`"}
{"instruction": "¿Qué es 'module augmentation' y cómo se usa?", "response": "Extiende módulos existentes: `declare module 'mi-modulo' { export interface Config { nuevaProp?: boolean; } }` Útil para añadir tipos a librerías."}
{"instruction": "Corrige: 'interface Box<T> { value: T; } const box: Box = { value: 5 };'", "response": "Falta el tipo genérico: `const box: Box<number> = { value: 5 };` o usar inferencia: `const box: Box<number> = { value: 5 };`"}
{"instruction": "Explica 'conditional types' con infer para promesas", "response": "Extrae el tipo dentro de Promise: `type UnpackPromise<T> = T extends Promise<infer U> ? U : T; type Resultado = UnpackPromise<Promise<string>>; // string`"}
{"instruction": "Muestra cómo tipar un middleware en Express con TypeScript", "response": "`import { Request, Response, NextFunction } from 'express'; const middleware = (req: Request, res: Response, next: NextFunction): void => { // lógica next(); };`"}
{"instruction": "¿Cómo tipar eventos de drag and drop?", "response": "`const handleDragStart = (e: React.DragEvent<HTMLDivElement>) => { e.dataTransfer.setData('text/plain', e.currentTarget.id); };` Usa DragEvent para eventos nativos."}
{"instruction": "Corrige: 'const useData = () => { const [data, setData] = useState(); return { data }; };'", "response": "useState necesita tipo o valor inicial: `const [data, setData] = useState<string | null>(null);` o `useState<Data[]>([]);`"}
{"instruction": "Explica 'type guards' con predicados personalizados", "response": "Funciones que devuelven type predicate: `function esUsuario(obj: any): obj is Usuario { return 'nombre' in obj && 'edad' in obj; }` Luego TypeScript narrows el tipo."}
{"instruction": "Muestra cómo usar 'Partial', 'Required' y 'Readonly' juntos", "response": "Se pueden combinar: `type User = { name?: string; age: number; }; type FullUser = Readonly<Required<User>>; // todas requeridas y readonly`"}
{"instruction": "¿Cómo tipar props de componentes con children como función (render props)?", "response": "`type Props = { children: (data: string) => React.ReactNode; }; const Component = ({ children }: Props) => { return children('datos'); };`"}
{"instruction": "Corrige: 'type Action = { type: 'ADD'; payload: string } | { type: 'REMOVE' }; const reducer = (state: string[], action: Action) => { switch (action.type) { case 'ADD': return [...state, action.payload]; } };'", "response": "Falta default case: `default: return state;` o case para 'REMOVE'. Además, el reducer debe retornar siempre el tipo del estado."}
{"instruction": "Explica 'template literal types' con uniones", "response": "Generan combinaciones: `type Event = 'click' | 'hover'; type Handler = `on${Capitalize<Event>}`; // 'onClick' | 'onHover'`. Útil para APIs consistentes."}
{"instruction": "Muestra cómo tipar un servicio API con axios", "response": "`import axios from 'axios'; interface ApiResponse { data: User[]; } const fetchUsers = async (): Promise<ApiResponse> => { return axios.get('/api/users'); }`"}
{"instruction": "¿Cómo usar 'Pick', 'Omit' y 'Partial' para updates?", "response": "Para PATCH updates: `type UserUpdate = Partial<Pick<User, 'name' | 'email'>>;`. O excluir ID: `type UserCreate = Omit<User, 'id'>;`"}
{"instruction": "Corrige: 'function procesar<T>(items: T[]): T { return items.reduce((acc, item) => acc + item); }'", "response": "No todos los tipos tienen '+'. Usa restricción: `function procesar<T extends number>(items: T[]): T { return items.reduce((acc, item) => acc + item as T); }`"}
{"instruction": "Explica 'branded types' para seguridad extra", "response": "Marcan tipos para evitar mezclas: `type UserId = string & { readonly __brand: 'UserId' }; type OrderId = string & { readonly __brand: 'OrderId' };`. Se crean con aserciones."}
{"instruction": "Muestra cómo tipar un componente genérico en React", "response": "`interface ListProps<T> { items: T[]; renderItem: (item: T) => React.ReactNode; } function List<T>({ items, renderItem }: ListProps<T>) { return items.map(renderItem); }`"}
{"instruction": "¿Cómo tipar un objeto con propiedades condicionales?", "response": "Usa uniones: `type Result<T> = { success: true; data: T; } | { success: false; error: string; };`. Luego discriminas con 'success'."}
{"instruction": "Corrige: 'const [state, setState] = useState<number>();'", "response": "useState con tipo pero sin valor inicial crea undefined. Corrección: `const [state, setState] = useState<number | undefined>(undefined);` o dar valor: `useState<number>(0);`"}
{"instruction": "Explica 'mapped types' con 'as' clause (key remapping)", "response": "TypeScript 4.1+: `type Getters<T> = { [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]; };`. Cambia nombres de propiedades."}
{"instruction": "Muestra cómo tipar contexto en React con useReducer", "response": "`type State = { count: number }; type Action = { type: 'increment' }; const Context = createContext<{ state: State; dispatch: Dispatch<Action> } | undefined>(undefined);`"}
{"instruction": "¿Cómo tipar funciones que trabajan con clases?", "response": "Usa `new` para constructores: `type Constructor = new (...args: any[]) => any;` o específico: `interface AnimalConstructor { new (name: string): Animal; }`"}
{"instruction": "Corrige: 'interface Props { onClick: () => void; } const Button = ({ onClick }: Props) => { return <button onClick={onClick()}>Click</button>; }'", "response": "onClick() llama la función al render. Debe ser referencia: `onClick={onClick}` o arrow: `onClick={() => onClick()}`"}
{"instruction": "Explica 'conditional types' distributivos", "response": "Con uniones: `type ToArray<T> = T extends any ? T[] : never; type Result = ToArray<string | number>; // string[] | number[]`. Se distribuye sobre cada miembro."}
{"instruction": "Muestra cómo tipar un custom hook que usa useEffect", "response": "`function useDocumentTitle(title: string): void { useEffect(() => { document.title = title; }, [title]); }` Tipado simple si no retorna nada."}
{"instruction": "¿Cómo tipar props con valores por defecto en React?", "response": "Usa defaultProps o valores por defecto en función: `const Component = ({ color = 'blue', size = 10 }: Props) => { ... };`. TypeScript infiere que son opcionales."}
{"instruction": "Corrige: 'type Keys = 'name' | 'age'; type Person = Record<Keys, string>; const p: Person = { name: 'John', age: 30 };'", "response": "'age' espera string pero recibe number. Cambia tipo: `Record<Keys, string | number>` o `const p = { name: 'John', age: '30' };`"}
{"instruction": "Explica 'template literal types' para rutas de API", "response": "`type Route = `/api/${'users' | 'posts'}/${string}`; const r1: Route = '/api/users/123'; // válido. Útil para rutas tipadas."}
{"instruction": "Muestra cómo tipar un objeto inmutable con 'as const' y tipos", "response": "`const config = { sizes: ['small', 'medium'] as const, colors: { red: '#ff0000' } as const } as const;`. Todo es readonly y literales."}
{"instruction": "¿Cómo tipar un reducer con acciones con payload opcional?", "response": "Usa discriminación de uniones: `type Action = { type: 'increment'; payload?: number } | { type: 'reset'; };`. El payload es opcional en increment."}
{"instruction": "Corrige: 'function identidad<T>(arg: T): T { if (typeof arg === 'string') { return arg.toUpperCase(); } return arg; }'", "response": "toUpperCase devuelve string, no T. Haz type narrowing pero retorna mismo tipo: `if (typeof arg === 'string') { return arg.toUpperCase() as T; }`"}
{"instruction": "Explica 'mapped types' con transformación de valores", "response": "Transforma tipos de valores: `type Stringify<T> = { [K in keyof T]: string; };`. Convierte todas las propiedades a string."}
{"instruction": "Muestra cómo tipar un evento de scroll infinito", "response": "`const handleScroll = (e: React.UIEvent<HTMLDivElement>) => { const { scrollTop, scrollHeight, clientHeight } = e.currentTarget; if (scrollHeight - scrollTop === clientHeight) { fetchMore(); } };`"}
{"instruction": "¿Cómo tipar una función que retorna diferentes tipos basado en entrada?", "response": "Usa overloads o conditional types: `function procesar<T extends 'text' | 'json'>(type: T): T extends 'text' ? string : object;`. Requiere implementación cuidadosa."}
{"instruction": "Corrige: 'const Component: React.FC = () => { const [data] = useState([]); return data.map(item => <div>{item.name}</div>); }'", "response": "El array vacío se infiere como never[]. Especifica tipo: `useState<{name: string}[]>([]);` o `useState([] as {name: string}[]);`"}
{"instruction": "Explica 'type predicates' vs 'type assertions'", "response": "Predicados: función que retorna `value is Type`. Assertions: `as Type`. Predicados son verificaciones en runtime, assertions son aserciones en tiempo de compilación."}
{"instruction": "Muestra cómo tipar un componente que acepta 'as' prop (polymorphic)", "response": "Usa generics y ComponentProps: `type Props<T extends React.ElementType> = { as?: T; } & React.ComponentPropsWithoutRef<T>;`. Avanzado pero poderoso."}
{"instruction": "¿Cómo tipar un árbol de nodos con recursión?", "response": "`interface TreeNode { value: string; children?: TreeNode[]; }`. La referencia circular se logra con interfaz o type alias."}
{"instruction": "Corrige: 'type Shape = { type: 'circle'; radius: number } | { type: 'square'; size: number }; function area(s: Shape): number { switch(s.type) { case 'circle': return Math.PI * s.radius ** 2; } }'", "response": "Falta case para 'square': `case 'square': return s.size ** 2; default: throw new Error('Shape not handled');`"}
{"instruction": "Explica 'conditional types' con never", "response": "`never` aparece en condiciones fallidas: `type Exclude<T, U> = T extends U ? never : T;`. Si T extiende U, se excluye (devuelve never, que desaparece en uniones)."}
{"instruction": "Muestra cómo tipar localStorage helper", "response": "`function useLocalStorage<T>(key: string, initialValue: T): [T, (value: T) => void] { const [stored, setStored] = useState<T>(() => { const item = localStorage.getItem(key); return item ? JSON.parse(item) : initialValue; }); // ... }`"}
{"instruction": "¿Cómo tipar un objeto con claves dinámicas pero valores conocidos?", "response": "Usa Record con unión: `type Theme = Record<'primary' | 'secondary', string>;` o template literal: `type Variants = Record<`size-${'sm' | 'lg'}`, number>;`"}
{"instruction": "Corrige: 'interface A { x: number; } interface B extends A { y: string; } const b: B = { x: 1 };'", "response": "Falta propiedad 'y'. Corrección: `const b: B = { x: 1, y: 'hello' };` o hacer 'y' opcional en B."}
{"instruction": "¿Cómo tipar un hook personalizado que retorna un array?", "response": "Para evitar ambigüedad con tuples, especifica tipos: `function useToggle(): [boolean, () => void] { ... }` o usa objeto nombrado: `function useToggle(): { state: boolean; toggle: () => void } { ... }`"}
{"instruction": "Corrige: 'type Props = { items: string[] }; const List = ({ items }: Props) => items.map(item => <li key={item}>{item}</li>);'", "response": "Falta wrapper o return. Si es componente React: `return <ul>{items.map(item => <li key={item}>{item}</li>)}</ul>;`"}
{"instruction": "Explica 'type guards' con 'in' operator para discriminación de uniones", "response": "`'prop' in obj` narrows el tipo: `type Shape = Circle | Square; function getArea(s: Shape) { if ('radius' in s) { return Math.PI * s.radius ** 2; } else { return s.side ** 2; } }`"}
{"instruction": "Muestra cómo tipar un evento de teclado en React", "response": "`const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => { if (e.key === 'Enter') { submit(); } };` Para nativo: `(e: KeyboardEvent)`"}
{"instruction": "¿Cómo usar 'Pick' y 'Omit' anidados?", "response": "Se pueden encadenar: `type User = { id: number; name: string; email: string; role: string; }; type UserProfile = Omit<Pick<User, 'id' | 'name' | 'email'>, 'email'>; // { id: number; name: string }`"}
{"instruction": "Corrige: 'const Component = ({ data }: { data: string }) => { return data.length > 0 ? <div>{data}</div> : null; };'", "response": "Está correcto, pero para claridad tipa Props separado: `type Props = { data: string }; const Component = ({ data }: Props) => ...`"}
{"instruction": "Explica 'mapped types' con transformación condicional", "response": "Usa conditional types dentro del mapped: `type Nullable<T> = { [K in keyof T]: T[K] extends object ? T[K] | null : T[K]; };`"}
{"instruction": "Muestra cómo tipar una función memoizada con useCallback", "response": "`const handleClick = useCallback((e: React.MouseEvent) => { console.log(e.currentTarget); }, []);` Especifica tipo de parámetro del callback."}
{"instruction": "¿Cómo tipar un objeto con propiedades opcionales dinámicas?", "response": "`type DynamicProps = { [key: `data-${string}`]: string; };` o con Record: `Record<`option-${number}`, boolean>`"}
{"instruction": "Corrige: 'interface Animal { name: string; } interface Dog extends Animal { breed: string; } const getAnimal = (): Animal => { return { name: 'Rex', breed: 'Labrador' }; };'", "response": "Retorna Dog pero se espera Animal. Corrección: `const getAnimal = (): Dog => { ... }` o castear: `return { name: 'Rex', breed: 'Labrador' } as Dog;`"}
{"instruction": "Explica 'type narrowing' con 'instanceof' para clases", "response": "`if (error instanceof Error) { console.log(error.message); }`. TypeScript sabe que dentro del bloque es tipo Error."}
{"instruction": "Muestra cómo tipar una promesa con timeout", "response": "`function timeout<T>(promise: Promise<T>, ms: number): Promise<T> { return Promise.race([promise, new Promise<T>((_, reject) => setTimeout(() => reject(new Error('Timeout')), ms))]); }`"}
{"instruction": "¿Cómo tipar un formulario con validación y estados de error?", "response": "`type FormState<T> = { values: T; errors: Partial<Record<keyof T, string>>; touched: Set<keyof T>; isSubmitting: boolean; };`"}
{"instruction": "Corrige: 'type Action = { type: 'LOGIN'; user: User } | { type: 'LOGOUT' }; const reducer = (state: AuthState, action: Action) => { switch (action.type) { case 'LOGIN': return { ...state, user: action.user }; } };'", "response": "Falta case 'LOGOUT' y default: `case 'LOGOUT': return { ...state, user: null }; default: return state;`"}
{"instruction": "Explica 'type inference' en funciones genéricas con restricciones", "response": "TypeScript infiere el tipo más específico: `function identity<T extends string | number>(x: T): T { return x; } identity('hello'); // T es string, identity(42); // T es number`"}
{"instruction": "Muestra cómo tipar un componente con forwardRef y props por defecto", "response": "`const Input = forwardRef<HTMLInputElement, InputProps>(({ type = 'text', ...props }, ref) => { return <input ref={ref} type={type} {...props} />; });`"}
{"instruction": "¿Cómo tipar un hook que usa IntersectionObserver?", "response": "`function useInView(ref: RefObject<Element>, options?: IntersectionObserverInit): boolean { const [isInView, setIsInView] = useState(false); useEffect(() => { const observer = new IntersectionObserver(([entry]) => setIsInView(entry.isIntersecting), options); // ... }, [ref, options]); return isInView; }`"}
{"instruction": "Corrige: 'const fetchData = async (url: string) => { const response = await fetch(url); return response.json() as User[]; };'", "response": "El cast 'as User[]' es inseguro. Mejor tipar promesa: `const fetchData = async (url: string): Promise<User[]> => { const response = await fetch(url); return response.json(); };`"}
{"instruction": "Explica 'type predicates' para validar objetos contra esquemas", "response": "`function isValidUser(obj: any): obj is User { return typeof obj.name === 'string' && typeof obj.age === 'number' && obj.age >= 0; }`. Luego if (isValidUser(data)) { /* data es User */ }"}
{"instruction": "Muestra cómo tipar un componente de ordenamiento genérico", "response": "`interface SortableListProps<T> { items: T[]; keyExtractor: (item: T) => string | number; renderItem: (item: T) => React.ReactNode; compareFn?: (a: T, b: T) => number; }`"}
{"instruction": "¿Cómo tipar un objeto con propiedades calculadas en runtime?", "response": "Usa `Record<string, any>` con validación o template literal types si los patrones son conocidos: `type Routes = Record<`/${string}`, () => void>`"}
{"instruction": "Corrige: 'type User = { name: string; }; type Admin = User & { permissions: string[]; }; const user: User = { name: 'Alice' }; const admin: Admin = user;'", "response": "No se puede asignar User a Admin sin permissions. Corrección: `const admin: Admin = { ...user, permissions: ['read'] };` o castear: `const admin = user as Admin;` (inseguro)"}
{"instruction": "Explica 'conditional types' con infer para extraer tipo de array", "response": "`type ElementType<T> = T extends (infer U)[] ? U : never; type Num = ElementType<number[]>; // number`. También funciona con ReadonlyArray."}
{"instruction": "Muestra cómo tipar una función de debounce", "response": "`function debounce<T extends (...args: any[]) => any>(func: T, wait: number): (...args: Parameters<T>) => void { let timeout: NodeJS.Timeout; return (...args: Parameters<T>) => { clearTimeout(timeout); timeout = setTimeout(() => func(...args), wait); }; }`"}
{"instruction": "¿Cómo tipar un contexto con valor por defecto complejo?", "response": "`const ThemeContext = React.createContext<{ theme: 'light' | 'dark'; toggleTheme: () => void }>({ theme: 'light', toggleTheme: () => {} });` Proveer valor real en Provider."}
{"instruction": "Corrige: 'const useCounter = () => { const [count, setCount] = useState(0); const increment = () => setCount(count + 1); return [count, increment]; };'", "response": "Retorna array que TypeScript infiere como (number | (() => void))[]. Especifica tuple: `return [count, increment] as const;` o `return [count, increment] as [number, () => void];`"}
{"instruction": "Explica 'type mapping' para hacer todas las propiedades nullable", "response": "`type Nullable<T> = { [K in keyof T]: T[K] | null; };`. Versión profunda recursiva es más compleja."}
{"instruction": "Muestra cómo tipar un componente que acepta icono como string o componente", "response": "`type IconProp = string | React.ComponentType<{ className?: string }>; interface ButtonProps { icon?: IconProp; }` Luego render condicional."}
{"instruction": "¿Cómo tipar un reducer con acciones anidadas?", "response": "Usa discriminación de uniones con payload opcional: `type Action = { type: 'update'; payload: Partial<State> } | { type: 'reset' };`. O acciones anidadas con 'subAction'."}
{"instruction": "Corrige: 'interface Config { readonly apiUrl: string; } const config: Config = { apiUrl: '/api' }; config.apiUrl = '/v2/api';'", "response": "No se puede modificar propiedad readonly. O quita readonly o crea nuevo objeto: `const newConfig = { ...config, apiUrl: '/v2/api' };`"}
{"instruction": "Explica 'branded types' para validación de emails", "response": "`type Email = string & { readonly __brand: 'Email' }; function createEmail(s: string): Email | null { return /^[^@]+@[^@]+$/.test(s) ? s as Email : null; }`. Garantiza emails válidos."}
{"instruction": "Muestra cómo tipar un hook que suscribe y desuscribe eventos", "response": "`function useEvent<K extends keyof WindowEventMap>(event: K, handler: (e: WindowEventMap[K]) => void) { useEffect(() => { window.addEventListener(event, handler); return () => window.removeEventListener(event, handler); }, [event, handler]); }`"}
{"instruction": "¿Cómo tipar un builder pattern con métodos encadenados?", "response": "`class QueryBuilder<T> { where(condition: Partial<T>): this { return this; } limit(n: number): this { return this; } }`. 'this' retorna instancia actual."}
{"instruction": "Corrige: 'type User = { id: number; name: string; }; type UserMap = Record<User['id'], User>;'", "response": "Record espera string | number | symbol como key. Corrección: `type UserMap = Record<number, User>;` o `type UserMap = Map<number, User>`"}
{"instruction": "Explica 'template literal types' para crear patrones CSS", "response": "`type Spacing = `${\`margin\` | \`padding\`}-\${'top' | 'bottom'}-\${number}px\`; const s: Spacing = 'margin-top-10px'; // válido`"}
{"instruction": "Muestra cómo tipar un hook de formulario con validación Yup", "response": "`function useForm<T extends object>(schema: yup.Schema<T>) { const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({}); const validate = async (data: T) => { try { await schema.validate(data, { abortEarly: false }); return true; } catch (err) { // manejar errores } }; }`"}
{"instruction": "¿Cómo tipar un componente con slots (children nombrados)?", "response": "`type Props = { header?: React.ReactNode; body: React.ReactNode; footer?: React.ReactNode; }; const Card = ({ header, body, footer }: Props) => ( <div> {header && <header>{header}</header>} <main>{body}</main> {footer && <footer>{footer}</footer>} </div> );`"}
{"instruction": "Corrige: 'const Button = ({ onClick, children }: { onClick(): void; children: any }) => { return <button onClick={onClick}>{children}</button>; };'", "response": "Evita 'any' para children. Usa `React.ReactNode`: `children: React.ReactNode`. También tipar onClick: `onClick: () => void` está bien."}
{"instruction": "Explica 'type inference' en callbacks de array methods", "response": "TypeScript infiere tipos en callbacks: `['a','b','c'].map(char => char.toUpperCase()); // char inferido como string`. Para objetos: `users.map(user => user.name)` infiere user."}
{"instruction": "Muestra cómo tipar un hook que usa WebSocket", "response": "`function useWebSocket(url: string, onMessage: (data: unknown) => void) { useEffect(() => { const ws = new WebSocket(url); ws.onmessage = (e) => onMessage(JSON.parse(e.data)); return () => ws.close(); }, [url, onMessage]); }` Tipar onMessage según datos esperados."}
{"instruction": "¿Cómo tipar un objeto de configuración con valores por defecto?", "response": "`interface Config { timeout: number; retries: number; } function createConfig(partial: Partial<Config> = {}): Config { return { timeout: 5000, retries: 3, ...partial }; }`"}
{"instruction": "Corrige: 'const MyComponent: FC<Props> = ({ title, content }) => ( <div> <h1>{title}</h1> <p>{content}</p> </div> );'", "response": "Está correcto si Props tiene title y content. Para mejores prácticas, evitar FC si no necesitas children: `const MyComponent = ({ title, content }: Props) => ...`"}
{"instruction": "Explica 'type narrowing' con 'typeof' para valores primitivos", "response": "`typeof value === 'string'` narrows a string, `'number'` a number, `'boolean'` a boolean, `'undefined'` a undefined, `'object'` a object o null (null es object!)."}
{"instruction": "Muestra cómo tipar un componente de paginación", "response": "`interface PaginationProps { currentPage: number; totalPages: number; onPageChange: (page: number) => void; disabled?: boolean; }`"}
{"instruction": "¿Cómo tipar una función que acepta múltiples tipos de argumentos?", "response": "Usa overloads o unión: `function parse(input: string): Data; function parse(input: string[]): Data[]; function parse(input: string | string[]): Data | Data[] { ... }`"}
{"instruction": "Corrige: 'type Response = { data: User[] } | { error: string }; const handleResponse = (res: Response) => { if (res.data) { return res.data.length; } else { return res.error; } };'", "response": "TypeScript no discrimina automáticamente. Usa 'in' operator: `if ('data' in res) { ... }` o añade propiedad discriminante: `type Response = { success: true; data: User[] } | { success: false; error: string };`"}
{"instruction": "Explica 'const assertions' con objetos literales", "response": "`const obj = { name: 'John', age: 30 } as const;` hace propiedades readonly y valores literales: `obj.name` es 'John' no string, `obj.age` es 30 no number."}
{"instruction": "Muestra cómo tipar un hook que gestiona múltiples estados relacionados", "response": "`function useFormFields<T extends Record<string, any>>(initial: T) { const [values, setValues] = useState<T>(initial); const update = (field: keyof T, value: T[keyof T]) => { setValues(prev => ({ ...prev, [field]: value })); }; return [values, update] as const; }`"}
{"instruction": "¿Cómo tipar un componente que renderiza condicionalmente?", "response": "`type Props = { condition: boolean; children: React.ReactNode; fallback?: React.ReactNode; }; const Conditional = ({ condition, children, fallback = null }: Props) => condition ? children : fallback;`"}
{"instruction": "Corrige: 'interface ComponentProps { size: 'small' | 'medium' | 'large'; } const Component = ({ size }: ComponentProps) => { const styles = { small: 'text-sm', medium: 'text-base', large: 'text-lg' }; return <div className={styles[size]}>Content</div>; };'", "response": "Está correcto si styles tiene todas las claves. Para seguridad extra: `const styles: Record<ComponentProps['size'], string> = { ... };`"}
{"instruction": "Explica 'type guards' para validar arreglos de tipos", "response": "`function isStringArray(arr: any[]): arr is string[] { return arr.every(item => typeof item === 'string'); }`. Útil para validar datos desconocidos."}
{"instruction": "Muestra cómo tipar una función de throttling", "response": "`function throttle<T extends (...args: any[]) => any>(func: T, limit: number): (...args: Parameters<T>) => void { let inThrottle: boolean; return (...args: Parameters<T>) => { if (!inThrottle) { func(...args); inThrottle = true; setTimeout(() => inThrottle = false, limit); } }; }`"}
{"instruction": "¿Cómo tipar un objeto con propiedades que dependen de otras?", "response": "Usa uniones discriminadas: `type ButtonProps = { variant: 'primary'; size: 'lg' | 'md' } | { variant: 'secondary'; size: 'sm' | 'md' };`. O intersection con never para combinaciones inválidas."}
{"instruction": "Corrige: 'type Shape = 'circle' | 'square'; const draw = (shape: Shape) => { switch (shape) { case 'circle': return '○'; case 'square': return '□'; } };'", "response": "Falta default o return exhaustivo. Agrega: `default: throw new Error(\`Unknown shape: ${shape}\`);` o TypeScript infiere retorno string (correcto si todos casos cubiertos)."}
{"instruction": "¿Cómo tipar una función que retorna un componente React condicionalmente?", "response": "Usa tipo de función que retorna `ReactElement | null`: `const ConditionalComponent = (shouldRender: boolean): React.ReactElement | null => shouldRender ? <div /> : null;` O mejor, tipar el componente directamente."}
{"instruction": "Corrige: 'type User = { id: string; name: string; }; const users: User[] = [{ id: '1', name: 'John' }]; const userMap = users.reduce((acc, user) => ({ ...acc, [user.id]: user }), {});'", "response": "Falta tipar el acumulador: `users.reduce<Record<string, User>>((acc, user) => ({ ...acc, [user.id]: user }), {});` Así `userMap` será `Record<string, User>`."}
{"instruction": "Explica 'satisfies' operator para validar sin ampliar tipos", "response": "`satisfies` verifica que un valor cumpla un tipo sin cambiar su inferencia: `const config = { color: 'red' } satisfies { color: string };`. Útil cuando quieres mantener tipos literales pero asegurar restricciones."}
{"instruction": "Muestra cómo tipar un hook que usa IntersectionObserver con ref", "response": "`function useInView(options?: IntersectionObserverInit) { const ref = useRef<Element>(null); const [isInView, setIsInView] = useState(false); useEffect(() => { const observer = new IntersectionObserver(([entry]) => setIsInView(entry.isIntersecting), options); if (ref.current) observer.observe(ref.current); return () => observer.disconnect(); }, [options]); return [ref, isInView] as const; }`"}
{"instruction": "¿Cómo tipar un objeto con propiedades que pueden ser funciones o valores?", "response": "Usa unión: `type ButtonConfig = { onClick: () => void; label: string | (() => string); }`. Luego verificar tipo al usar: `const label = typeof config.label === 'function' ? config.label() : config.label;`"}
{"instruction": "Corrige: 'interface Props { value: string; onChange: (value: string) => void; } const Input = (props: Props) => { return <input value={props.value} onChange={e => props.onChange(e.target)} />; };'", "response": "`e.target` es HTMLElement, no string. Usa `e.target.value`: `onChange={e => props.onChange(e.target.value)}`"}
{"instruction": "Explica 'type narrowing' con 'switch' y literales string", "response": "Switch discrimina uniones: `type Action = { type: 'ADD'; payload: string } | { type: 'DELETE' }; function reducer(state: string[], action: Action) { switch (action.type) { case 'ADD': return [...state, action.payload]; case 'DELETE': return state.slice(0, -1); } }`"}
{"instruction": "Muestra cómo tipar una función que memoiza resultados", "response": "`function memoize<T extends (...args: any[]) => any>(fn: T): T { const cache = new Map(); return ((...args: Parameters<T>) => { const key = JSON.stringify(args); if (cache.has(key)) return cache.get(key); const result = fn(...args); cache.set(key, result); return result; }) as T; }`"}
{"instruction": "¿Cómo tipar un componente que acepta estilos inline o className?", "response": "`type StyleProps = { className?: string; style?: React.CSSProperties; }; const Box = ({ className, style, children }: StyleProps & { children?: React.ReactNode }) => <div className={className} style={style}>{children}</div>;`"}
{"instruction": "Corrige: 'type Props = { items: string[]; renderItem?: (item: string) => React.ReactNode; }; const List = ({ items, renderItem }: Props) => { return items.map(item => renderItem ? renderItem(item) : item); };'", "response": "El retorno debe ser ReactNode, no string. Corrección: `return <>{items.map(item => renderItem ? renderItem(item) : <span key={item}>{item}</span>)}</>;` O envolver en fragment."}
{"instruction": "Explica 'template literal types' para crear tipos de rutas con parámetros", "response": "`type Route = \`/users/\${string}/posts/\${string}\` | \`/dashboard/\${'stats' | 'settings'}\`; const route1: Route = '/users/123/posts/456'; // válido. Útil para APIs tipadas."}
{"instruction": "Muestra cómo tipar un custom hook que gestiona localStorage", "response": "`function useLocalStorage<T>(key: string, initialValue: T): [T, (value: T) => void] { const [stored, setStored] = useState<T>(() => { try { const item = window.localStorage.getItem(key); return item ? JSON.parse(item) : initialValue; } catch { return initialValue; } }); const setValue = (value: T) => { setStored(value); localStorage.setItem(key, JSON.stringify(value)); }; return [stored, setValue]; }`"}
{"instruction": "¿Cómo tipar un objeto con claves que siguen un patrón regex?", "response": "No se puede tipar con regex, pero puedes usar template literals: `type EnvVars = Record<\`VITE_\${string}\`, string>;` o validar en runtime con type guard."}
{"instruction": "Corrige: 'const Component = () => { const [data, setData] = useState(); useEffect(() => { fetch('/api').then(res => setData(res.json())); }, []); return <div>{data?.name}</div>; };'", "response": "`res.json()` es Promise. Usa `await` o `.then`: `fetch('/api').then(res => res.json()).then(data => setData(data));` También tipar estado: `useState<{name: string} | null>(null);`"}
{"instruction": "Explica 'type predicates' para validar estructuras de objetos complejas", "response": "`function isProduct(obj: any): obj is Product { return obj && typeof obj.id === 'string' && typeof obj.price === 'number' && (obj.category === undefined || typeof obj.category === 'string'); }`. Validaciones exhaustivas."}
{"instruction": "Muestra cómo tipar un componente de tabla genérico", "response": "`interface TableProps<T> { data: T[]; columns: { key: keyof T; header: string; render?: (value: T[keyof T], row: T) => React.ReactNode; }[]; }` Luego mapear data y columns."}
{"instruction": "¿Cómo tipar eventos de cambio en formularios con múltiples inputs?", "response": "`const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => { setForm(prev => ({ ...prev, [e.target.name]: e.target.value })); };` Tipar estado con `Record<string, string>` o interfaz específica."}
{"instruction": "Corrige: 'type Foo = { bar: string; }; type Baz = Foo & { bar: number; };'", "response": "Intersección crea `never` para `bar` (string & number). Es error de diseño. Usa unión o renombra: `type Baz = Omit<Foo, 'bar'> & { bar: number; }`"}
{"instruction": "Explica 'mapped types' para crear readonly versiones profundas", "response": "`type DeepReadonly<T> = { readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K]; };`. Recursivo para objetos anidados."}
{"instruction": "Muestra cómo tipar un hook de paginación con fetch", "response": "`function usePagination<T>(fetchPage: (page: number) => Promise<T[]>) { const [data, setData] = useState<T[]>([]); const [page, setPage] = useState(1); useEffect(() => { fetchPage(page).then(newData => setData(prev => [...prev, ...newData])); }, [page, fetchPage]); return { data, loadMore: () => setPage(p => p + 1) }; }`"}
{"instruction": "¿Cómo tipar un callback que puede ser síncrono o asíncrono?", "response": "Usa unión: `type Callback = () => void | Promise<void>;`. Luego manejar ambos: `const result = callback(); if (result instanceof Promise) await result;`"}
{"instruction": "Corrige: 'const Button = ({ children, ...props }: React.ButtonHTMLAttributes<HTMLButtonElement>) => { return <button {...props}>{children}</button>; };'", "response": "Está correcto, pero para componentes personalizados, extiende props: `type ButtonProps = React.ButtonHTMLAttributes<HTMLButtonElement> & { variant?: 'primary' | 'secondary'; };`"}
{"instruction": "Explica 'type inference' en funciones de orden superior", "response": "`function wrapper<T>(fn: (x: T) => T) { return fn; } wrapper((x: number) => x + 1); // T inferido como number`. TypeScript infiere de los argumentos."}
{"instruction": "Muestra cómo tipar un componente que acepta 'as' prop con React.createElement", "response": "`function Polymorphic<T extends React.ElementType = 'div'>({ as, ...props }: { as?: T } & React.ComponentPropsWithoutRef<T>) { const Component = as || 'div'; return <Component {...props} />; }` Avanzado pero flexible."}
{"instruction": "¿Cómo tipar un reducer con side effects async?", "response": "Para async, usa middleware como Redux Thunk. El reducer sigue síncrono: `type Action = { type: 'FETCH_SUCCESS'; data: Data } | { type: 'FETCH_ERROR'; error: string };`. Async se maneja en acción."}
{"instruction": "Corrige: 'type Config = { url: string; timeout: number; }; const config: Partial<Config> = { url: '/api' }; const fullConfig: Config = { ...config, timeout: 5000 };'", "response": "Error porque `config` es `Partial<Config>` y puede faltar `url`. Si sabes que está, aseverar: `const config = { url: '/api' } as Partial<Config>;` o usar default values."}
{"instruction": "Explica 'branded types' para IDs con diferentes tipos", "response": "`type UserId = string & { readonly __type: 'UserId' }; type OrderId = string & { readonly __type: 'OrderId' };`. Previene mezclar IDs: `function getUser(id: UserId) { ... }` solo acepta UserId."}
{"instruction": "Muestra cómo tipar un hook que usa requestAnimationFrame", "response": "`function useAnimationFrame(callback: (deltaTime: number) => void) { const requestRef = useRef<number>(); const previousTimeRef = useRef<number>(); const animate = (time: number) => { if (previousTimeRef.current) callback(time - previousTimeRef.current); previousTimeRef.current = time; requestRef.current = requestAnimationFrame(animate); }; useEffect(() => { requestRef.current = requestAnimationFrame(animate); return () => cancelAnimationFrame(requestRef.current!); }, [callback]); }`"}
{"instruction": "¿Cómo tipar un objeto con propiedades que dependen de una condición en runtime?", "response": "Usa unión discriminada: `type Result = { success: true; data: Data } | { success: false; error: string };`. Luego chequeas `result.success` en runtime."}
{"instruction": "Corrige: 'interface Animal { name: string; } interface Dog extends Animal { breed: string; } const animals: Animal[] = []; const dogs: Dog[] = animals;'", "response": "No se puede asignar Animal[] a Dog[] (Animal puede no tener breed). Corrección: `const dogs: Dog[] = animals.filter((a): a is Dog => 'breed' in a);` o revisar diseño."}
{"instruction": "Explica 'type mapping' para convertir unión a intersección", "response": "`type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;`. Avanzado, útil para combinar tipos."}
{"instruction": "Muestra cómo tipar un componente de gráficos con datos genéricos", "response": "`interface ChartProps<T> { data: T[]; xKey: keyof T; yKey: keyof T; color?: string; } const Chart = <T,>({ data, xKey, yKey, color }: ChartProps<T>) => { ... };`"}
{"instruction": "¿Cómo tipar una función que retorna diferente tipo basado en boolean?", "response": "Usa overloads o conditional types: `function parse<T extends boolean>(strict: T): T extends true ? Data : Data | null;`. Implementación requiere type assertion."}
{"instruction": "Corrige: 'const Component = ({ onClick }: { onClick: (event: MouseEvent) => void }) => { return <button onClick={onClick}>Click</button>; };'", "response": "MouseEvent es nativo, React usa `React.MouseEvent`. Corrección: `onClick: (event: React.MouseEvent) => void`. O importar MouseEvent de React."}
{"instruction": "Explica 'type guards' con discriminación de uniones usando constante", "response": "Propiedad constante discrimina: `type Message = { kind: 'text'; content: string } | { kind: 'image'; url: string }; function handle(m: Message) { if (m.kind === 'text') console.log(m.content); else console.log(m.url); }`"}
{"instruction": "Muestra cómo tipar un hook que usa Web Workers", "response": "`function useWorker<T>(workerScript: string, onMessage: (data: T) => void) { const workerRef = useRef<Worker>(); useEffect(() => { const worker = new Worker(workerScript); workerRef.current = worker; worker.onmessage = (e) => onMessage(e.data); return () => worker.terminate(); }, [workerScript, onMessage]); return workerRef; }`"}
{"instruction": "¿Cómo tipar un objeto con propiedades que son arrays de longitud fija?", "response": "Usa tuplas: `type Point3D = [number, number, number];` o en objetos: `interface Model { vertices: [number, number, number][]; }`. También `readonly [number, number]`."}
{"instruction": "Corrige: 'type A = string | number; type B = A & boolean;'", "response": "`B` es `never` porque no hay intersección entre `string|number` y `boolean`. Revisa lógica: quizás querías unión: `type B = A | boolean;`"}
{"instruction": "Explica 'conditional types' para extraer tipo de propiedad", "response": "`type PropType<T, K extends keyof T> = T extends { [P in K]: infer U } ? U : never; type X = PropType<{ a: string; b: number }, 'a'>; // string`. Similar a `T[K]` pero con infer."}
{"instruction": "Muestra cómo tipar un formulario con steps/wizard", "response": "`type Step = 'personal' | 'address' | 'payment'; type FormData = { [K in Step]?: Record<string, any>; }; const [currentStep, setCurrentStep] = useState<Step>('personal');` Luego datos por step."}
{"instruction": "¿Cómo tipar un componente que renderiza lista virtualizada?", "response": "`interface VirtualListProps<T> { items: T[]; itemHeight: number; renderItem: (item: T, index: number) => React.ReactNode; containerHeight: number; }` Necesita cálculo de ventana visible."}
{"instruction": "Corrige: 'const Component = () => { const ref = useRef<HTMLDivElement>(); return <div ref={ref} />; };'", "response": "`useRef` inicialmente `undefined`. Pasa null: `useRef<HTMLDivElement>(null);` o usar `useRef<HTMLDivElement | null>(null);` y check null."}
{"instruction": "Explica 'type narrowing' con 'Array.isArray'", "response": "`Array.isArray(value)` narrows a `any[]`: `if (Array.isArray(value)) { value.push(1); }`. Para tipar mejor: `if (Array.isArray(value) && value.every(v => typeof v === 'string')) { // string[] }`"}
{"instruction": "Muestra cómo tipar un hook que gestiona tiempo (timer)", "response": "`function useInterval(callback: () => void, delay: number | null) { const savedCallback = useRef(callback); useEffect(() => { savedCallback.current = callback; }, [callback]); useEffect(() => { if (delay !== null) { const id = setInterval(() => savedCallback.current(), delay); return () => clearInterval(id); } }, [delay]); }`"}
{"instruction": "¿Cómo tipar una API client con métodos CRUD?", "response": "`interface ApiClient { get<T>(url: string): Promise<T>; post<T>(url: string, data: unknown): Promise<T>; // etc. }` Implementar con fetch o axios tipado."}
{"instruction": "Corrige: 'type Props = { value: string | number; }; const Display = ({ value }: Props) => { return <div>{value.toUpperCase()}</div>; };'", "response": "`toUpperCase` no existe en number. Chequear tipo: `{typeof value === 'string' ? value.toUpperCase() : value.toString()}` o restringir props."}
{"instruction": "Explica 'type mapping' para hacer propiedades opcionales condicionalmente", "response": "`type OptionalIf<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;`. Más avanzado: `type ConditionalOptional<T, K extends keyof T> = { [P in keyof T]: P extends K ? T[P] | undefined : T[P]; }`"}
{"instruction": "Muestra cómo tipar un componente con slots con nombre usando children", "response": "`type SlotProps = { children: React.ReactNode; }; const Header = ({ children }: SlotProps) => <header>{children}</header>; const Layout = ({ children }: { children: React.ReactNode }) => { // children puede ser Header, Main, etc. };`"}
{"instruction": "¿Cómo tipar un hook que usa ResizeObserver?", "response": "`function useResizeObserver(ref: React.RefObject<Element>, callback: (entries: ResizeObserverEntry[]) => void) { useEffect(() => { if (!ref.current) return; const observer = new ResizeObserver(callback); observer.observe(ref.current); return () => observer.disconnect(); }, [ref, callback]); }`"}
{"instruction": "Corrige: 'const Component = ({ data }: { data: { id: string }[] }) => { return data.map(item => <div key={item.id}>{item.name}</div>); };'", "response": "`item` no tiene `name`. Corrección: `data: { id: string; name: string }[]` o usar propiedad existente: `{item.id}`"}
{"instruction": "Explica 'template literal types' para BEM CSS classes", "response": "`type BEM = \`block\${'__element' | ''}\${'--modifier' | ''}\`; const className: BEM = 'block__element--modifier'; // válido. Útil para sistemas de clases tipadas."}
{"instruction": "Muestra cómo tipar un hook que sincroniza estado con URL", "response": "`function useQueryParam(key: string): [string | null, (value: string | null) => void] { const [value, setValue] = useState(() => new URLSearchParams(window.location.search).get(key)); // sincronizar con history API }`"}
{"instruction": "¿Cómo tipar un objeto con propiedades que son funciones de diferentes aridades?", "response": "Usa unión o sobrecarga: `type Handler = ((a: string) => void) | ((a: string, b: number) => void);`. Al llamar, necesitas saber qué función es."}
{"instruction": "Corrige: 'const Component = () => { const [count, setCount] = useState(0); useEffect(() => { setCount(count + 1); }, []); return <div>{count}</div>; };'", "response": "`setCount` en useEffect causa re-render infinito porque cambia count, que no está en dependencias. Para montaje: `setCount(c => c + 1);` o dejar dependencias vacías si es solo montaje."}
{"instruction": "Explica 'type predicates' para validar objetos con esquema Zod", "response": "Zod ya provee type inference: `const schema = z.object({ name: z.string() }); type Data = z.infer<typeof schema>;`. Luego `schema.safeParse(data)` retorna resultado tipado."}
{"instruction": "Muestra cómo tipar un componente que acepta iconos como React component o string", "response": "`type Icon = React.ComponentType<{ size?: number }> | string; const IconRender = ({ icon }: { icon: Icon }) => { if (typeof icon === 'string') return <img src={icon} />; const IconComponent = icon; return <IconComponent size={24} />; };`"}
{"instruction": "¿Cómo tipar un reducer para estado inmutable con Immer?", "response": "Con Immer, el draft es mutable pero tipado: `const reducer = produce((draft: Draft<State>, action: Action) => { switch (action.type) { case 'UPDATE': draft.value = action.payload; } });`. `Draft` de Immer."}